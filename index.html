<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Automatic Complex Event Implementation System (ACEIS) by fenggao86</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Automatic Complex Event Implementation System (ACEIS)</h1>
      <h2 class="project-tagline">Middleware for modelling, planning and adaptive implementation of complex event services.</h2>
      <a href="https://github.com/fenggao86/ACEIS" class="btn">View on GitHub</a>
      <a href="https://github.com/fenggao86/ACEIS/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/fenggao86/ACEIS/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="overview-of-aceis" class="anchor" href="#overview-of-aceis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview of ACEIS</h3>

<p>The Automatic Complex Event Implementation System (ACEIS) is a middleware for complex event services. It is implemented to fulfill large-scale data analysis requirements in the <a href="http://ict-citypulse.eu/">CityPulse</a> project and is responsible for event service discovery, composition, deployment, execution and adaptation. In the CityPulse project, data streams are annotated as event services, using the <a href="http://citypulse.insight-centre.org/ontology/ces/">Complex Event Service Ontology</a>. Event service discovery and composition refer to finding a data stream or a composite set of data streams to address the user-defined event request. Event service deployment refers to transforming the event service composition results (a.k.a., composition plans) into RDF Stream Processing (RSP) queries and registering these queries to relevant RSP engines, e.g., <a href="https://code.google.com/archive/p/cqels/">CQELS</a> and <a href="http://streamreasoning.org/download">C-SPARQL</a>. Event service execution refers to establishing the input and output connections for the RSP engines to allow them consuming real-time data from lower-level data providers and delivering query results to upper-level data consumers. Event services adaptation ensures the quality constraints over event services are ensured at run-time, by detecting quality changes and make adjustments automatically. The figure below illustrates the architecture of ACEIS.</p>

<p><img src="http://fenggao86.github.io/ACEIS/architecture.jpg" alt="Architecture of ACEIS"></p>

<p>ACEIS can be used in scenarios where on-demand discovery and composition of data streams are needed, and RSP is used for evaluating queries over the data streams e.g.:</p>

<ul>
<li>Scenario 1: monitoring traffic conditions over different streets and regions in a city for a city administrator.</li>
<li>Scenario 2: planning the travel routes for a citizen based on his/her functional and non-functional requirements.</li>
</ul>

<p>ACEIS cannot be used in situations where queries or streams used for the queries are fixed, i.e., no on-demand stream discovery and composition possible/necessary.</p>

<h3>
<a id="known-limitations" class="anchor" href="#known-limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Known limitations</h3>

<p>ACEIS has the following limitations:</p>

<ul>
<li> <strong>Event Semantics</strong>: The expressiveness of event requests with regard to temporal and logical correlations is limited to AND, OR, SEQUENCE and REPETITIONS, as described in <a href="http://dl.acm.org/citation.cfm?id=2611287">this paper</a>, and the events modeled in ACEIS are instant events, i.e., only one timestamp allowed for each event. Interval-based events are not supported. </li>
<li> <strong>RSP Engine Types</strong>:  Currently only CQELS and C-SPARQL engines are supported for event service execution. However, a third-party developer can integrate new engines by extending the query transformation module.</li>
<li> <strong>Concurrent Queries</strong>: Existing RSP engines are still in their early stages and there is room for performance optimization. Currently, the data federation component can handle approximately 1000 CQELS or 90 C-SPARQL queries in parallel, by applying a load-balancing technique. A larger number of concurrent queries may (depending on the query complexity) result in unstable engine status.</li>
</ul>

<h3>
<a id="possible-extensions" class="anchor" href="#possible-extensions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Possible Extensions</h3>

<p>ACEIS can be extended to:</p>

<ul>
<li>support more expressive event semantics by extending the event models, event reusability definitions and the event service composition algorithms,</li>
<li>support more RSP engines by extending the query transformation algorithms and </li>
<li>employ more advanced adaptation algorithms.</li>
</ul>

<h3>
<a id="userguide" class="anchor" href="#userguide" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>User Guide</h3>

<p>A sample main class can be found at "org.insight_centre.citypulse.main.MultipleInstanceMain.java", below we provide some basic examples and explanations of the code, in order to demonstrate how it works.</p>
<pre><code>
  public static void main(String[] args) throws Exception {
  	//load the property file
  	Properties prop = new Properties();
  	File in = new File("aceis.properties");
	FileInputStream fis = new FileInputStream(in);
	prop.load(fis);
	fis.close();
	
	//load run-time parameters
	HashMap<String, String> parameters = new HashMap<String, String>();
	for (String s : args) {
		parameters.put(s.split("=")[0], s.split("=")[1]);
	}
	
	//start server
	MultipleInstanceMain mim = new MultipleInstanceMain(prop, parameters);
	mim.startServer();
	}
  </code></pre>
  <p>configurable properties ("aceis.properties"):
  <ul>
<li>hostIp: the IP address of the server hosting data federation server,</li>
<li>port: the main port used by the data federation server,</li>
<li>ontology:  the folder storing the ontology files (used only if local dataset files are used),</li>
<li>streams: the folder storing the stream data files for simulation (used only if operating on simulated streams),</li>
<li>dataset: the location of stream meta-data, could be a local file or an URI for the virtuoso endpoint provided by the resource management component,</li>
<li>request: the location of sample test queries.</li>
</ul>
  </p>
  <p>run-time parameters:
  <ul>
  <li>cqelsCnt: number of CQELS engine instances,</li>
<li>csparqlCnt: number of CSPARQL engine instances,</li>
<li>smode: load balancing strategy, could be "elastic", "balancedLatency", "balancedQueries", "rotation" or "elastic",</li>
<li>qCnt: number of concurrent queries (used only in simulation mode),</li>
<li>step: interval between registering new queries (used only in simulation mode),</li>
<li>query: path to the query file (used only in simulation mode),</li>
<li>duration: life-time of the ACEIS server instance, 0 means indefinite.</li>
  	</ul>
  	</p>
  	<p>The <code>startServer()</code> method in the constructor of <code>MultipleInstanceMain</code> has the following steps:</p>
  	<pre><code>
private void startServer() throws Exception {
	// Initialize ACEIS engine(s) using ACEISScheduler
	ACEISScheduler.smode = this.smode;
	ACEISScheduler.initACEISScheduler(cqelsCnt, csparqlCnt, dataset);
	
	// start websocket servers
	Server server = new Server(this.hostIp, this.port, "/", null, MultipleEngineServerEndpoint.class); // main server endpoint
	//Server server2 = new Server(this.hostIp, 8002, "/", null, SubscriberServerEndpoint2.class); // obselete server for mobile travel planner
	Server server3 = new Server(this.hostIp, 8020, "/", null, ConflictResolutionServerEndpoint.class); // conflict resolution server endpoint
	Session session = null;
	try {
		server.start();
		//server2.start();
		server3.start();
		
		// for local tests
		// sendRequest(step);
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		System.out.print("Please press a key to stop the server.");
		reader.readLine();
	} catch (Exception e) {
		e.printStackTrace();
		throw new RuntimeException(e);
	} finally {
		logger.info("Stopping Server.");
		session.close();
		server.stop();
		System.exit(0);
		}

	}
  		
  	</code></pre>
  	<p>At run-time, when a new message is received by the main server endpoint (<code>MultipleEngineServerEndpoint.java</code>), the <code>onMessage</code> method is invoked, which takes the following actions:
  		</p>
<pre><code>
@OnMessage
public String onMessage(String message, Session session) throws Exception {
	if (message.equals("quit")) {// when message contains "quit", close the session for this client
		try {
			session.close(new CloseReason(CloseCodes.NORMAL_CLOSURE, "Subscriber ended"));
		} catch (Exception e) {
			logger.error("Error occur while stopping streams.");
			e.printStackTrace();
			session.getBasicRemote().sendText("FAULT: " + e.getMessage());
			logger.info("Sending error msg: " + e.getMessage());
			throw new RuntimeException(e);
		}
	} else if (message.contains("stop")) {// when message contains "stop", deregister the query but keep the session
		try {
			ACEISEngine engine = engineMap.get(session);
			SubscriptionManagerFactory.getSubscriptionManager().deregisterEventRequest(sessionPlanMap.get(session),
					false);
		} catch (Exception e) {
			logger.error("Error occur while stopping streams.");
			e.printStackTrace();
			session.getBasicRemote().sendText("FAULT: Error occur while stopping streams. " + e.getMessage());
			logger.info("Sending error msg: " + e.getMessage());
		}
	} else {// process normal queries
		try {
			// logger.info("Handling single query");
			this.parseMsg(message, session);
			//
			if (!MultipleInstanceMain.getMonitor().isStarted()) {
				new Thread(MultipleInstanceMain.getMonitor()).start();
				logger.info("Monitor thread started.");
			}
		} catch (Exception e) {
			e.printStackTrace();
			session.getBasicRemote().sendText("FAULT: " + e.getMessage());
			logger.info("Sending error msg: " + e.getMessage());
		}
	}
	return null;
}
	</code></pre>
	<p> The method <code>parseMsg()</code> is used to analyse the received message </p>
	<pre><code>
private void parseMsg(String msgStr, Session session) throws Exception {
	// generate an EventRequest from the msgStr in Json format
	EventRequest request = new Gson().fromJson(msgStr, EventRequest.class);
	logger.info("Engine type: " + request.getEngineType());
	
	// choose proper RSP engine instance for this request
	ACEISEngine engine = ACEISScheduler.getBestEngineInstance(request.getEngineType());
	engineMap.put(session, engine);
	
	if (request.isContinuous()) {
		// if the request asks for continuous results, register the query on the RSP engine
		this.registerQueryFromEventRequest(request, session);
	} else { 
		// if it is a "one-time" request, return the snapshot for the relevant sensor data using the data-fetching server.
		logger.info("Parsing data fetching request.");
		List<String> sids = new ArrayList<String>();
		for (EventDeclaration e : request.getEp().getEds())
			sids.add(e.getServiceId());
		DataFederationResult result = new DataFederationResult();
		for (String s : sids) {
			logger.info("sid: " + s);
			EventDeclaration ed = engine.getRepo().getEds().get(s);
			HashMap<String, String> snapshot = VirtuosoDataManager.getSnapShot(ed);
			for (Entry<String, String> en : snapshot.entrySet()) {
				result.getResult().put(en.getKey(), new ArrayList<String>());
				result.getResult().get(en.getKey()).add(en.getValue());
			}
		}
		String resultStr = new Gson().toJson(result);
		logger.info("sending response: " + resultStr);
		session.getBasicRemote().sendText(resultStr);
	}
}
		</code></pre>
<p> The event requests are modelled in package <code>org.insight_centre.aceis.eventmodel</code>, which has the following components:	</p>
<b>EventRequest:</b><ul>
<li>ep: the query pattern</li>
<li>constraint: the qos constraint vector, can be null</li>
<li>weight: the qos weight vector, can be null</li>
<li>continuous: specify if it is a continous query or not, to be set 'true' in this scenario</li>
<li>engineType: type of RDF processing engine to be used, can be 'CQELS' or 'CSPARQL'</li>
<li>aggOp: aggregation operator, can be avg, min or max</li></ul>
<b>EventPattern:</b><ul>
<li>eds: list of event declarations, i.e., sensors used in the query</li>
<li>eos: list of event operators, to be set to 'and' in this scenario</li>
<li>filters: list of filters, empty in this scenario</li>
<li>ID: random pattern id</li>
<li>idCnt: initial size of pattern, to be ignored</li>
<li>temporalMap: temporal relation between event operators and event declarations (id strings as keys and values, same for provenancemap)</li>
<li>provenanceMap: provenance relation between event operators and event declarations</li>
<li>isQuery: indicate if the pattern is a query or not, to be set to 'true' in the request</li>
<li>timewindow: the time window of the pattern in milliseconds, can be set to a recommended '3000' as in the sample</li>
<li>trafficDemand: placeholder for network traffic estimation, to be set to '0' in the request</li>
<li>selections: selected properties from sensors</li></ul>

<b>EventDeclaration:</b><ul>
<li>distance: placeholder field, ignore</li>
<li>eventType: domain specific sensor type</li>
<li>foi: feature of interest, for traffic sensors the format is (startlatitude,startlongituede-endlatitude,endlongitude)</li>
<li>nodeId: random sensorId</li></ul>

<b>Selection:</b><ul>
<li>propertyName: random name/id of the property </li>
<li>providedBy: the id of the provider for this property</li>
<li>foi: the foi of the property</li>
<li>propertyType: the domain specific type of the property</li>
<li>originalED: the object reference of the provider, i.e., the event declaration/sensor</li></ul>
 
<h3>	
<a id="api" class="anchor" href="#api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API</h3>

<p>Javadoc for ACEIS can be found at <a href="doc/index.html">here</a></p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>ACEIS is developed by Feng Gao (<a href="https://github.com/fenggao86" class="user-mention">@fenggao86</a>) at 2015.
Author page and relevant publications can be found <a href="https://www.insight-centre.org/users/feng-gao">here</a></p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Author contacts: <a href="mailto:feng.gao@insight-centre.org">feng.gao@insight-centre.org</a>, <a href="mailto:frostfel0@gmail.com">frostfel0@gmail.com</a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/fenggao86/ACEIS">Automatic Complex Event Implementation System (ACEIS)</a> is maintained by <a href="https://github.com/fenggao86">fenggao86</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-73065128-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
